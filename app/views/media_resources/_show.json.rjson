h = {
  id: media_resource.id,
  type: media_resource.class.to_s.underscore # TODO .type ??
}

if (with || nil)
  if with[:image]
    size = with[:image][:size] || :small # TODO :small_125 ??
    h[:image] = case with[:image][:as]
      when "base64"
        mf = if media_resource.is_a?(MediaSet)
              media_resource.media_entries.accessible_by_user(current_user).order("media_resources.updated_at DESC").first.try(:media_file)
             else
              media_resource.media_file
             end
        mf ? mf.thumb_base64(size) : nil
      else # default return is a url to the image
        "/media_resources/%d/image?size=%s" % [id, size]
    end            
  end
  
  if with[:meta_data]
    h[:meta_data] = []
    if meta_context_names = with[:meta_data][:meta_context_names]
      meta_context_names.each do |name|
        media_resource.meta_data_for_context(MetaContext.find_by_name(name)).each do |md|
          h[:meta_data].push render(:partial => "meta_data/show.json.rjson", :locals => {:meta_datum => md})
        end
      end
    end
  end
  
  if with[:media_type]
    h[:media_type] = media_resource.media_type
  end
  
  if with[:filename]
    h[:filename] = media_resource.is_a?(MediaSet) ? nil : media_resource.media_file.filename
  end

  if with[:flags]
    h[:is_public] = media_resource.is_public?
    h[:is_private] = h[:is_public] ? false : media_resource.is_private?(current_user)
    h[:is_shared] = (not h[:is_public] and not h[:is_private]) # TODO drop and move to frontend
    h[:is_editable] = current_user.authorized?(:edit, media_resource)
    h[:is_manageable] = current_user.authorized?(:manage, media_resource)
    h[:is_favorite] = current_user.favorite_ids.include?(media_resource.id)
  end
end

h
